Design a Vending Machine

  Add items to the vending machine in fixed number of slots
  Payment using card or cash
  Select item to dispense


Requirements:
  User should be able to select a slot number and get the product
  System should also support payment via cash, card, UPI, wallet, etc
  Admin should be able to topup items in the slot
  Admin should be able to override the price for a slot as well
  Machine should decline item request if inventory is empty for that slot

Entity
  Vending Machine
  Vending Machine state
  Slot
  Admin
  Payment
  Audit
  Payment Method

Entity detail

  Admin
    id
    employee number
    email
    phone number
    name
    ...

  Slot
    number
    price
    quantity

  Vending Machine State
    BEGIN
    DECIDING_PAYMENT_MODE
    PAYMENT_STATE
    PAYMENT_FAILED
    PAYMENT_SUCCESS
    EMPTY_SLOT

  Vending machine
    // data members
    vending machine state // state for keeping track of the journey progress
    current slot number // state to rememeber the selected slot
    unordered_map<int, slot> slotMap; // slot data, on success quantity is reduced by 1, also used for getting price for payment
    configured timeout // used to trip the machine into begin state, when user input takes more than this much amount of time
    payment provider factory // losely coupled payment provider provider
    audit service // used to capture the events across the machine

    // methods
    select slot (slot number) // state has to be begin else throw error
    chose payment method (payment mode) // state has to be deciding payment mode here
    make txn (payment mode, int amount) // state has to be payment state
    dispatch (slot number) // post success of payment machine calls this method to dispatch the selected item
    configure slot(admin id, slot number, quantity, price) // admin method to override the current slot config
    reset state () // used when either the machine trips due to timeout or due to invalid method invocation at a state, this updates the internal state and the selected slot id to -1

  Payment Mode
    CASH
    UPI
    CARD
    WALLET

  Payment Provider
    pay(int amount)

  Cash payment provider
   pay(int amount)

  UPI payment provider
    pay (int amount)

  Wallet payment provider
    pay (int amount)

  Payment Provider factory
    get provider (payment mode) : Payment Provider

  Audit Service
    audit (event)
    get history (admin id)

  Event
    id
    name
    timestamp
    data

Journeys:

User buys something
  1. User selects a slot number
  2. If the slot number provided is invalid machine displays error
  3. If the slot is empty machine displays error
  4. current slot number state is modified to the provided slot number
  5. machine state is set to chose payment mode
  6. as per state the machine asks the user for selecting a payment mode
  7. User selects a payment mode
  8. machine updates the state to payment
  9. Machine gets the payment amount from the slot
  10. Machine gets the payment provider for the mode from the factory
  11. Machine calls the payment method // basis the implementation of the provider it either displays QR, asks for cash, etc
  12. Once the payment is completed
  13. Machine dispatches the item in front of that slot

  // in any of the above step if the user input takes more than the configured timeout, machine timesout and set the state to begin again, updates the selected slot id to -1
  // for all the above actions, events are generated by the machine and sent to the audit service, audit service keeps a write ahead log and keeps appending to it
  // if wrong method is called which mismatches the current machine state, we reset the state, selected slot id and renders the error on screen

Admin configures the slot
  1. Admin logs into the machine
  2. Admin physically either removes the item / add new items / replaces the exising or empty slot with new items of diff type
  3. Admin then calls the configure slot method, with the slot id, quantity, price, this overwrites the existing data for that slot
  
  // When admin is operating on the machine, it will not service the regular users
  // All the admin events are also logged into the machine, which admin can view
